var documenterSearchIndex = {"docs":
[{"location":"performance/#Achieve-Performance","page":"Achieve performance","title":"Achieve Performance","text":"","category":"section"},{"location":"performance/#Using-StaticArrays.jl","page":"Achieve performance","title":"Using StaticArrays.jl","text":"","category":"section"},{"location":"performance/","page":"Achieve performance","title":"Achieve performance","text":"One way to improve the performance of the package when solving system of PDEs, is to use the package StaticArrays.jl to define the PDE formulation.","category":"page"},{"location":"performance/","page":"Achieve performance","title":"Achieve performance","text":"This package allows you to use arrays that are stored on the stack rather than on the heap, which eliminates the need for memory allocation when defining and evaluating the problem. In contrast, when using arrays to define the problem, it creates heap-allocations for every interval where the function is evaluated.","category":"page"},{"location":"performance/#Example","page":"Achieve performance","title":"Example","text":"","category":"section"},{"location":"performance/","page":"Achieve performance","title":"Achieve performance","text":"using SkeelBerzins, StaticArrays\n\n# Define symmetry of the problem\nm = 0\n\n# Define PDE Formulation\nfunction pdefunction(x,t,u,dudx)\n    c = SVector(1,1)\n    f = SVector(0.5,0.1) .* dudx\n    y = u[1] - u[2]\n    s = SVector(-y, y)\n\n    c,f,s\nend\n\n# Define the initial condition\nfunction icfunction(x)\n    u0 = SVector(0.0, 0.0)\n    \n    u0\nend\n\n# Define the boundary condtions\nfunction bdfunction(xl,ul,xr,ur,t)\n    pl = SVector(ul[1]-1.0, 0)\n    ql = SVector(0, 1)\n    pr = SVector(0, ur[2])\n    qr = SVector(1, 0)\n\n    pl,ql,pr,qr\nend\n\n# Define the spatial discretization\nxmesh = collect(range(0,1,length=21))\n\n# Define the time interval\ntspan = (0,10)\n\n# Solve\nsol = pdepe(m,pdefunction,icfunction,bdfunction,xmesh,tspan ; solver=:euler,tstep=1e-2)","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Examples coming soon!","category":"page"},{"location":"problem_definition/#Problem-Definition","page":"Problem Definition","title":"Problem Definition","text":"","category":"section"},{"location":"problem_definition/#Problem-format","page":"Problem Definition","title":"Problem format","text":"","category":"section"},{"location":"problem_definition/","page":"Problem Definition","title":"Problem Definition","text":"Before attempting to solve a problem described by partial differential equation(s) (PDE(s)), it is necessary to express the equation(s) in a form that can be understood and processed by the solver.","category":"page"},{"location":"problem_definition/","page":"Problem Definition","title":"Problem Definition","text":"Let us first define 1D discretization grids, for n in mathbbN:","category":"page"},{"location":"problem_definition/","page":"Problem Definition","title":"Problem Definition","text":"a = x_1  cdots  x_n = b quad text and  quad t_0  cdots  t_end  ","category":"page"},{"location":"problem_definition/","page":"Problem Definition","title":"Problem Definition","text":"The number of points n in the spatial discretization should be chosen based on the desired level of accuracy and the complexity of the solution.","category":"page"},{"location":"problem_definition/","page":"Problem Definition","title":"Problem Definition","text":"We then need to consider the following system of quasilinear partial differential equations:","category":"page"},{"location":"problem_definition/","page":"Problem Definition","title":"Problem Definition","text":"c(xtuu_x)u_t = x^-m(x^m f(xtuu_x))_x + s(xtuu_x)","category":"page"},{"location":"problem_definition/","page":"Problem Definition","title":"Problem Definition","text":"where m denotes the symmetry of the problem (m=0, m=1 or m=2 denoting cartesian, polar cylindrical and polar spherical coordinates respectively), while the functions c(xtuu_x), f(xtuu_x) and s(xtuu_x) represent the capacity term, the flux term and the source term respectively.\nThe capacity term c(xtuu_x) must be represented as a diagonal matrix (see SkeelBerzins.mass_matrix), this means that the relationship between the partial derivatives with respect to time is limited to being multiplied by a diagonal matrix c(xtuu_x).","category":"page"},{"location":"problem_definition/","page":"Problem Definition","title":"Problem Definition","text":"Similarly, the boundary conditions associated to the PDE(s) must conform to a specific format, which is outlined as follows:","category":"page"},{"location":"problem_definition/","page":"Problem Definition","title":"Problem Definition","text":"p^i(xtu) + q^i(xt)f^i(xtuu_x) = 0 quad textfor  x=a text or  x=b","category":"page"},{"location":"problem_definition/","page":"Problem Definition","title":"Problem Definition","text":"with i=1cdotsnpde (number of PDEs).","category":"page"},{"location":"problem_definition/","page":"Problem Definition","title":"Problem Definition","text":"warning: Warning\nThe reference [1] states that if m0 then we require a geq 0 for the method to work properly.","category":"page"},{"location":"problem_definition/","page":"Problem Definition","title":"Problem Definition","text":"The package utilizes the spatial discretization method outlined in reference [1], which results in a second-order accurate method in space.","category":"page"},{"location":"problem_definition/","page":"Problem Definition","title":"Problem Definition","text":"Please refer to the example provided below and the section on solvers to understand how to implement the problem in the required format.","category":"page"},{"location":"problem_definition/#Example","page":"Problem Definition","title":"Example","text":"","category":"section"},{"location":"problem_definition/#Linear-Diffusion-for-m0-with-homogeneous-Neumann-boundary-conditions","page":"Problem Definition","title":"Linear Diffusion for m=0 with homogeneous Neumann boundary conditions","text":"","category":"section"},{"location":"problem_definition/","page":"Problem Definition","title":"Problem Definition","text":"We rewrite a linear diffusion problem in cartesian coordinates, with homogeneous Neumann boundary conditions, to conform to the format outlined above.","category":"page"},{"location":"problem_definition/","page":"Problem Definition","title":"Problem Definition","text":"We have for x in ab, t in t_0t_end","category":"page"},{"location":"problem_definition/","page":"Problem Definition","title":"Problem Definition","text":"u_t(xt) = u_xx(xt) \nfracdudx(at) = fracdudx(bt) = 0 \nu(xt_0) = u_0(x)","category":"page"},{"location":"problem_definition/","page":"Problem Definition","title":"Problem Definition","text":"In the format required by the solver, it gives:","category":"page"},{"location":"problem_definition/","page":"Problem Definition","title":"Problem Definition","text":"m = 0 quad  \nc(xtuu_x) = 1 quad  \nf(xtuu_x) = u_x quad  \ns(xtuu_x) = 0 quad  \np(xtu) = 0 quad text for  x=a text and  x=b quad  \nq(xt) = 1 quad text for  x=a text and  x=b  ","category":"page"},{"location":"public_private_APIs/#Public-and-private-APIs","page":"Public and Private APIs","title":"Public and private APIs","text":"","category":"section"},{"location":"public_private_APIs/","page":"Public and Private APIs","title":"Public and Private APIs","text":"We present here an index of all the methods that are present in the package. These are separated into two classes:","category":"page"},{"location":"public_private_APIs/","page":"Public and Private APIs","title":"Public and Private APIs","text":"Public API\nPrivate API","category":"page"},{"location":"public_private_APIs/#Public-API","page":"Public and Private APIs","title":"Public API","text":"","category":"section"},{"location":"public_private_APIs/#Solvers","page":"Public and Private APIs","title":"Solvers","text":"","category":"section"},{"location":"public_private_APIs/","page":"Public and Private APIs","title":"Public and Private APIs","text":"pdepe","category":"page"},{"location":"public_private_APIs/#SkeelBerzins.pdepe","page":"Public and Private APIs","title":"SkeelBerzins.pdepe","text":"pdepe(m, pdefunction, icfunction, bdfunction, xmesh, tspan ; solver=:euler, tstep=1e-3, hist=false, sparsity=:sparseArray, linSol=:umfpack)\n\nSolve 1D elliptic and/or parabolic partial differential equation(s) using the spatial discretization method described in [1]. The time discretization is either done by the implicit Euler method (internal method) or by using a ODE/DAE solver from the DifferentialEquations.jl package. For more information on how to define the different inputs to solve a problem, look at (link problem definition...).\n\nInput arguments:\n\nm: scalar refering to the symmetry of the problem. It can either take the value m=0, m=1 or m=2 representing       cartesian, cylindrical or spherical coordinates respectively.\npdefunction: Function. Defines the PDE(s) formulation that incorporates capacity, flux and source terms.\nicfunction: Function. Defines the initial condition of the system to solve (if tstep neq Inf - initial condition from the ODE/DAE problem,                else if tstep = Inf - initial value used for the newton solver).\nbdfunction: Function. Defines the boundary conditions of the problem.\nxmesh: one-dimensional array representing the mesh on which the user wants to obtain the solution.\ntspan: tuple (t_0 t_end) representing the time interval of the problem.\n\nKeyword arguments:\n\nsolver: choice of the time discretization either use :euler for internal implicit Euler method or :diffEq for the DifferentialEquations.jl package (by default :euler).\ntstep: defines a time step (either pass a Float64 or a Vector) when using the implicit Euler method (by default to 1e-3).           When set to tstep=Inf, it solves the stationary version of the problem.\nhist: flag, returns with the solution, a list of 1d-array with the history from the newton solver (by default false).\nsparsity: choice of the type of matrix (:sparseArray, :exSparse, :banded) use to store the jacobian (by default :sparseArray).\nlinSol: choice of the solver for the LSE in the newton method (:umfpack, :LinearSolve, :klu) (by default :umfpack).\n\nReturns a RecursiveArrayTools.DiffEqArray, a SkeelBerzins.ProblemDefinition structure or a 1D Array, depending on the chosen solver.\n\n\n\n\n\npdepe(m, pdefunction, icfunction, bdfunction, xmesh ; hist=false, sparsity=:sparseArray)\n\nSolve 1D elliptic PDE(s) using the spatial discretization method described in [1] - pdepe variant to solve stationary problems. Performs one step of the implicit Euler method. For more information, look at link implicit Euler...\n\nInput arguments:\n\nm: scalar refering to the symmetry of the problem. It can either take the value m=0, m=1 or m=2 representing       cartesian, cylindrical or spherical coordinates respectively.\npdefunction: Function. Defines the PDE(s) formulation which includes the capacity, flux and source terms (capacity term should be set to 0).\nicfunction: Function. It defines the initial value used for the Newton solver.\nbdfunction: Function. Defines the boundary conditions of the problem.\nxmesh: one-dimensional array representing the mesh on which the user wants to obtain the solution.\n\nKeyword arguments:\n\nhist: flag, returns with the solution, a 1d-array with the history from the newton solver (by default false).\nsparsity: choice of the type of matrix (:sparseArray, :exSparse, :banded) use to store the jacobian (by default :sparseArray).\nlinSol: choice of the solver for the LSE in the newton method (:umfpack, :LinearSolve, :klu) (by default :umfpack).\n\nReturns a 1D Array with the solution at the points from the spatial discretization xmesh.\n\n\n\n\n\n","category":"function"},{"location":"public_private_APIs/#Compatibility-with-DifferentialEquations.jl","page":"Public and Private APIs","title":"Compatibility with DifferentialEquations.jl","text":"","category":"section"},{"location":"public_private_APIs/","page":"Public and Private APIs","title":"Public and Private APIs","text":"SciMLBase.ODEProblem\nBase.reshape","category":"page"},{"location":"public_private_APIs/#SciMLBase.ODEProblem","page":"Public and Private APIs","title":"SciMLBase.ODEProblem","text":"ODEProblem(problem,callback=DifferentialEquations.CallbackSet())\n\nGenerate an ODEProblem from the ODEFunction which then can be solved by using the DifferentialEquations.solve() method.\n\nInput arguments:\n\nproblem: Structure of type SkeelBerzins.ProblemDefinition.\ncallback: (optional) see callback.\n\n\n\n\n\n","category":"type"},{"location":"public_private_APIs/#Base.reshape","page":"Public and Private APIs","title":"Base.reshape","text":"reshape(sol_ODE, problem)\n\nReshape the solution sol_ODE obtained by the DifferentialEquations.jl package to obtain the solution at time t as a 2D-Array of size (npde,Nx). \n\nIndeed since in the spatial discretization, we flattened the problem, the solution has a similar size.  So by reshaping the solution, we get a solution organised by unknows.\n\n\n\n\n\n","category":"function"},{"location":"public_private_APIs/#Private-API","page":"Public and Private APIs","title":"Private API","text":"","category":"section"},{"location":"public_private_APIs/","page":"Public and Private APIs","title":"Public and Private APIs","text":"These methods should only be considered for developers or people trying to understand the inner workings of the package.","category":"page"},{"location":"public_private_APIs/#Spatial-Discretization","page":"Public and Private APIs","title":"Spatial Discretization","text":"","category":"section"},{"location":"public_private_APIs/","page":"Public and Private APIs","title":"Public and Private APIs","text":"SkeelBerzins.assemble!\nSkeelBerzins.interpolation\nSkeelBerzins.interpolation!","category":"page"},{"location":"public_private_APIs/#SkeelBerzins.assemble!","page":"Public and Private APIs","title":"SkeelBerzins.assemble!","text":"assemble!(du, u, problem, t)\n\nPerforms space discretization following the difference equations described in [1].\n\nAssemble the right-hand side f to generate an ODE/DAE problem:\n\nM fracdudt = f(uproblemt)\n\nwhere the input problem is defined as a SkeelBerzins.ProblemDefinition structure.\n\nThis function is specified in a way that it is compatible with the DifferentialEquations.jl package.\n\n\n\n\n\n","category":"function"},{"location":"public_private_APIs/#SkeelBerzins.interpolation","page":"Public and Private APIs","title":"SkeelBerzins.interpolation","text":"interpolation(xl, ul, xr, ur, quadrature_point, problem)\n\nInterpolate u and fracdudx between two discretization points at some specific quadrature point.\n\nInput arguments:\n\nxl: left boundary of the current interval.\nul: solution evaluated at the left boundary of the current interval.\nxr: right boundary of the current interval.\nur: solution evaluated at the right boundary of the current interval.\nquadrature_point: quadrature point chosen according to the method described in [1].\nproblem: Structure of type SkeelBerzins.ProblemDefinition.\n\n\n\n\n\n","category":"function"},{"location":"public_private_APIs/#SkeelBerzins.interpolation!","page":"Public and Private APIs","title":"SkeelBerzins.interpolation!","text":"interpolation!(interp, d_interp, xl, ul, xr, ur, quadrature_point, problem)\n\nMutating version of the interpolation function.\n\n\n\n\n\n","category":"function"},{"location":"public_private_APIs/#Newton-solvers","page":"Public and Private APIs","title":"Newton solvers","text":"","category":"section"},{"location":"public_private_APIs/","page":"Public and Private APIs","title":"Public and Private APIs","text":"SkeelBerzins.newton\nSkeelBerzins.newton_stat","category":"page"},{"location":"public_private_APIs/#SkeelBerzins.newton","page":"Public and Private APIs","title":"SkeelBerzins.newton","text":"newton(b, tau, timeStep, problem, mass_matrix, cache, rhs ; tol=1.0e-10, maxit=100, hist_flag=false)\n\nNewton method solving nonlinear system of equations.\n\nInput arguments:\n\nb: right-hand side of the system to solve.\ntau: constant time step used for the time discretization.\ntimeStep: current time step of tspan.\nproblem: Structure of type SkeelBerzins.ProblemDefinition.\nmass_matrix: mass matrix of the problem, see [mass_matrix][@ref].\ncache: ForwardColorCache. To avoid allocating the cache in each iteration of the newton solver when computing the jacobian.\nrhs: preallocated vector to avoid creating allocations.\n\nKeyword arguments:\n\ntol: tolerance or stoppping criteria (by default to 1.0e-10).\nmaxit: maximum number of iterations (by default to 100).\nhist_flag: flag to save the history and returns it (by default to false).\nlinSol: choice of the solver for the LSE (:umfpack, :LinearSolve, :klu) (by default :umfpack).\n\nReturns the solution of the nonlinear system of equations and if hist_flag=true, the history of the solver.\n\n\n\n\n\n","category":"function"},{"location":"public_private_APIs/#SkeelBerzins.newton_stat","page":"Public and Private APIs","title":"SkeelBerzins.newton_stat","text":"newton_stat(b, tau, timeStep, problem, cache, rhs ; tol=1.0e-10, maxit=100, hist_flag=false)\n\nNewton method solving nonlinear system of equations (variant of newton for stationary problems).\n\n\n\n\n\n","category":"function"},{"location":"public_private_APIs/#Problem-definition","page":"Public and Private APIs","title":"Problem definition","text":"","category":"section"},{"location":"public_private_APIs/","page":"Public and Private APIs","title":"Public and Private APIs","text":"SkeelBerzins.ProblemDefinition","category":"page"},{"location":"public_private_APIs/#SkeelBerzins.ProblemDefinition","page":"Public and Private APIs","title":"SkeelBerzins.ProblemDefinition","text":"mutable struct ProblemDefinition{T, Tv<:Number, Ti<:Integer, Tm<:Number, pdeFunction<:Function, icFunction<:Function, bdFunction<:Function}\n\nMutable structure storing the problem definition.\n\nnpde::Integer: Number of unknowns\n\nNx::Integer: Number of discretization points\n\nxmesh::Vector{Tv} where Tv<:Number: Grid of the problem\n\ntspan::Tuple{Tm, Tm} where Tm<:Number: Time interval\n\nsingular::Bool: Flag to know if the problem is singular or not\n\nm::Integer: Symmetry of the problem\n\njac::Union{ExtendableSparse.ExtendableSparseMatrix{Tv, Ti}, SparseArrays.SparseMatrixCSC{Tv, Ti}, BandedMatrices.BandedMatrix{Tv}} where {Tv<:Number, Ti<:Integer}: Jacobi matrix\n\ninival::Vector{Tv} where Tv<:Number: Evaluation of the initial condition\n\nξ::Vector{Tv} where Tv<:Number: Interpolation points from the paper\n\nζ::Vector{Tv} where Tv<:Number\npdefunction::Function: Function defining the coefficients of the PDE\n\nicfunction::Function: Function defining the initial condition\n\nbdfunction::Function: Function defining the boundary conditions\n\ninterpolant::Vector{Tv} where Tv<:Number: Preallocated vectors for interpolation in assemble! function when solving system of PDEs\n\nd_interpolant::Vector{Tv} where Tv<:Number\n\n\n\n\n\n","category":"type"},{"location":"public_private_APIs/#Implicit-Euler-method","page":"Public and Private APIs","title":"Implicit Euler method","text":"","category":"section"},{"location":"public_private_APIs/","page":"Public and Private APIs","title":"Public and Private APIs","text":"SkeelBerzins.implicitEuler!\nSkeelBerzins.implicitEuler_stat!\nSkeelBerzins.mass_matrix","category":"page"},{"location":"public_private_APIs/#SkeelBerzins.implicitEuler!","page":"Public and Private APIs","title":"SkeelBerzins.implicitEuler!","text":"implicitEuler!(y,u,problem,tau,mass_matrix,timeStep)\n\nAssemble the system for the implicit Euler method.\n\n\n\n\n\n","category":"function"},{"location":"public_private_APIs/#SkeelBerzins.implicitEuler_stat!","page":"Public and Private APIs","title":"SkeelBerzins.implicitEuler_stat!","text":"implicitEuler_stat!(y,u,problem,tau,timeStep)\n\nAssemble the system for the implicit Euler method (variant method for stationary problems).\n\n\n\n\n\n","category":"function"},{"location":"public_private_APIs/#SkeelBerzins.mass_matrix","page":"Public and Private APIs","title":"SkeelBerzins.mass_matrix","text":"mass_matrix(problem)\n\nAssemble the diagonal mass matrix M of the system of differential equations  when solving a problem with at least one parabolic PDE. The coefficients from M either take the value 0 or 1 since it is scaled in the  difference equations in the right-hand side.\n\nThe entries of the matrix are set to 0 when the corresponding equation of the system is elliptic or the boundary condition is pure Dirichlet leading to solve a Differential-Algebraic system of Equations. In the case where the mass matrix is identity, we solve a system of ODEs.\n\n\n\n\n\n","category":"function"},{"location":"public_private_APIs/#Compatibility-with-DifferentialEquations.jl-2","page":"Public and Private APIs","title":"Compatibility with DifferentialEquations.jl","text":"","category":"section"},{"location":"public_private_APIs/","page":"Public and Private APIs","title":"Public and Private APIs","text":"The ODEFunction constructor is implicitely defined in the ODEProblem and so doesn't need to be considered by the user to solve the problem with the DifferentialEquations.jl package.","category":"page"},{"location":"public_private_APIs/","page":"Public and Private APIs","title":"Public and Private APIs","text":"SciMLBase.ODEFunction","category":"page"},{"location":"public_private_APIs/#SciMLBase.ODEFunction","page":"Public and Private APIs","title":"SciMLBase.ODEFunction","text":"ODEFunction(problem)\n\nGenerate an ODEFunction  from the spatial discretization derived in the assemble! function. It is expressed as a mass matrix ODE and defines the problem with respect to the sparsity pattern.\n\nInput argument:\n\nproblem: Structure of type SkeelBerzins.ProblemDefinition.\n\n\n\n\n\n","category":"type"},{"location":"solvers/#Solvers","page":"Solvers","title":"Solvers","text":"","category":"section"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"Now that we have an understanding of the overall problem definition, we can look into the various solvers included in the package and investigate their specific input and output parameters in detail.","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"The solvers expect the PDE problem to be described in the following way.","category":"page"},{"location":"solvers/#Define-the-PDE","page":"Solvers","title":"Define the PDE","text":"","category":"section"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"In order to define the PDE(s), we have to follow the format introduced in the previous section on Problem definition. For the purpose of this explanation, we use the function pdefunction(x,t,u,dudx) to describe the PDE(s). The inputs of the function are self-explanatory. It will then returns the capacity c(x,t,u,dudx), the flux f(x,t,u,dudx) and the source s(x,t,u,dux) terms (refer to the previous section).","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"This function will be passed as an argument to the solver.","category":"page"},{"location":"solvers/#Define-the-initial-conditions","page":"Solvers","title":"Define the initial conditions","text":"","category":"section"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"To define the initial condition(s), we introduce the function icfunction(x). For problems that contain at least one parabolic equation, it will return the evaluation of the initial condition on the spatial mesh xmesh at the initial time t_0.\nFor stationary problems it will return the evaluation of the initial value on the spatial mesh xmesh used for the newton solver.","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"This function will be passed as an argument to the solver.","category":"page"},{"location":"solvers/#Define-the-boundary-conditions","page":"Solvers","title":"Define the boundary conditions","text":"","category":"section"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"To represent the boundary condition, we introduce the function bdfunction(xl,ul,xr,ur,t). The input arguments are:","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"xl : left boundary point of the problem.\nul : estimate of the solution evaluated at the left boundary of the domain.\nxr : right boundary point of the problem.\nur : estimate of the solution evaluated at the right boundary of the domain.\nt : evaluates the boundary conditions at time t in t_0t_end.","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"The function will return the terms of the boundary conditions introduced in the problem defintion section, i.e. p(x,t,u) and q(x,t) for the left and right part of the spatial mesh.","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"warning: Warning\nIf m0 and the left boundary point of the domain a=0, the solver ignores the given boundary condition to enforce the symmetry condition.","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"This function will be passed as an argument to the solver.","category":"page"},{"location":"solvers/#Obtaining-Solutions","page":"Solvers","title":"Obtaining Solutions","text":"","category":"section"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"Having defined the PDE formulation, the solver function pdepe can now be introduced. Look pdepe.","category":"page"},{"location":"solvers/#Internal-method:-implicit-Euler-method","page":"Solvers","title":"Internal method: implicit Euler method","text":"","category":"section"},{"location":"solvers/#Parabolic-equation(s)","page":"Solvers","title":"Parabolic equation(s)","text":"","category":"section"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"When aiming to solve a problem that includes at least one parabolic equation, we can use the internal implicit Euler method.","category":"page"},{"location":"solvers/#Elliptic-Equations","page":"Solvers","title":"Elliptic Equations","text":"","category":"section"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"Only the internal method can be used to solve stationary problems and it is written in the following manner:","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"M fracu^k+1-u^kDelta t = A(u^k+1)","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"with M the mass matrix, Delta t the time step used for the time discretization, A the (non)linear operator resulting from the space discretization, u^k and u^k+1 the estimate solutions at time t_0 + k Delta t and t_0 + (k+1) Delta t respectively.","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"In Julia, positive infinity is defined as Inf. By setting Delta t = Inf, it follows that frac1Delta t = 0 and thus we are left with the stationary problem which can solved by using the Newton solver.","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"It results that the solution for the stationary problem can be obtained by running one iteration of the implicit Euler method.","category":"page"},{"location":"solvers/#Solve-with-DifferentialEquations.jl","page":"Solvers","title":"Solve with DifferentialEquations.jl","text":"","category":"section"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"SkeelBerzins.jl is also compatible with the DifferentialEquations.jl package.","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"It is possible to return the data from the problem in a SkeelBerzins.ProblemDefinition structure, then to define an ODEFunction, an ODEProblem and solve it using any ODE/DAE solvers from DifferentialEquations.jl.","category":"page"},{"location":"solvers/#Examples","page":"Solvers","title":"Examples","text":"","category":"section"},{"location":"solvers/#Solve-linear-diffusion-problem-in-cartesian-coordinates-with-homogeneous-Neumann-boundary-conditions-using-internal-implicit-Euler-method","page":"Solvers","title":"Solve linear diffusion problem in cartesian coordinates with homogeneous Neumann boundary conditions using internal implicit Euler method","text":"","category":"section"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"using SkeelBerzins\n\n# Define symmetry of the problem\nm = 0\n\n# Define PDE Formulation\nfunction pdefunction(x,t,u,dudx)\n    c = 1\n    f = dudx\n    s = 0\n\n    c,f,s\nend\n\n# Define the initial condition\nicfunction(x) = exp(-100*(x-0.25)^2)\n\n# Define the boundary condtions\nfunction bdfunction(xl,ul,xr,ur,t)\n    pl = 0\n    ql = 1\n    pr = 0\n    qr = 1\n\n    pl,ql,pr,qr\nend\n\n# Define the spatial discretization\nxmesh = collect(range(0,1,length=21))\n\n# Define the time interval\ntspan = (0,1)\n\n# Solve\nsol = pdepe(m,pdefunction,icfunction,bdfunction,xmesh,tspan ; solver=:euler,tstep=1e-3)","category":"page"},{"location":"solvers/#Solve-linear-diffusion-problem-in-cartesian-coordinates-with-homogeneous-Neumann-boundary-conditions-using-the-DifferentialEquations.jl","page":"Solvers","title":"Solve linear diffusion problem in cartesian coordinates with homogeneous Neumann boundary conditions using the DifferentialEquations.jl","text":"","category":"section"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"using SkeelBerzins, DifferentialEquations\n\n# Define symmetry of the problem\nm = 0\n\n# Define PDE Formulation\nfunction pdefunction(x,t,u,dudx)\n    c = 1\n    f = dudx\n    s = 0\n\n    c,f,s\nend\n\n# Define the initial condition\nicfunction(x) = exp(-100*(x-0.25)^2)\n\n# Define the boundary condtions\nfunction bdfunction(xl,ul,xr,ur,t)\n    pl = 0\n    ql = 1\n    pr = 0\n    qr = 1\n\n    pl,ql,pr,qr\nend\n\n# Define the spatial discretization\nxmesh = collect(range(0,1,length=21))\n\n# Define the time interval\ntspan = (0,1)\n\n# Solve\nproblem_data = pdepe(m,pdefunction,icfunction,bdfunction,xmesh,tspan ; solver=:diffEq)\nproblem_ode = DifferentialEquations.ODEProblem(problem_data)\nsol_ode = DifferentialEquations.solve(problem,Rosenbrock23())\nsol = reshape(sol_ode,problem_data)","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Markdown\nMarkdown.parse(\"\"\"\n$(read(\"../../README.md\",String))\n\"\"\")","category":"page"}]
}
