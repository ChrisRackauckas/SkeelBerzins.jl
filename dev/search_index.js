var documenterSearchIndex = {"docs":
[{"location":"performance/#Achieve-Performance","page":"Achieve performance","title":"Achieve Performance","text":"","category":"section"},{"location":"performance/#Using-StaticArrays.jl","page":"Achieve performance","title":"Using StaticArrays.jl","text":"","category":"section"},{"location":"performance/","page":"Achieve performance","title":"Achieve performance","text":"One way to improve the performance of the package when solving system of PDEs, is to use the package StaticArrays.jl to define the PDE formulation.","category":"page"},{"location":"performance/","page":"Achieve performance","title":"Achieve performance","text":"This package allows you to use arrays that are stored on the stack rather than on the heap, which eliminates the need for memory allocation when defining and evaluating the problem. Indeed normally when using arrays to define the problem, it will create allocations for every interval where we evaluate the function.","category":"page"},{"location":"performance/#Example","page":"Achieve performance","title":"Example","text":"","category":"section"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Examples coming soon!","category":"page"},{"location":"problem_definition/#Problem-Definition","page":"Problem Definition","title":"Problem Definition","text":"","category":"section"},{"location":"problem_definition/","page":"Problem Definition","title":"Problem Definition","text":"Before solving the problem defined by partial differential equation(s), we define how to write it down. Indeed the solver requires that the PDE(s) must respect a particular format.","category":"page"},{"location":"problem_definition/","page":"Problem Definition","title":"Problem Definition","text":"We need to consider the following system of quasilinear partial differential equations:","category":"page"},{"location":"problem_definition/","page":"Problem Definition","title":"Problem Definition","text":"cleft(xtuu_xright)u_t = x^-mleft(x^m f(xtuu_x)right)_x + rleft(xtuu_xright)","category":"page"},{"location":"problem_definition/","page":"Problem Definition","title":"Problem Definition","text":"with the following boundary conditions:","category":"page"},{"location":"problem_definition/","page":"Problem Definition","title":"Problem Definition","text":"d(xtu) + n(xt)f(xtuu_x) = 0","category":"page"},{"location":"problem_definition/","page":"Problem Definition","title":"Problem Definition","text":"Warning: In the case where m0, it follows that a geq 0.","category":"page"},{"location":"problem_definition/","page":"Problem Definition","title":"Problem Definition","text":"The spatial discretization from the package follows the one described in [1] resulting in second-order accurate method in space.","category":"page"},{"location":"public_private_APIs/#Public-and-private-APIs","page":"Public and Private APIs","title":"Public and private APIs","text":"","category":"section"},{"location":"public_private_APIs/","page":"Public and Private APIs","title":"Public and Private APIs","text":"We present here an index of all the methods that are present in the package. These are separated into two classes:","category":"page"},{"location":"public_private_APIs/","page":"Public and Private APIs","title":"Public and Private APIs","text":"Public API\nPrivate API","category":"page"},{"location":"public_private_APIs/#Public-API","page":"Public and Private APIs","title":"Public API","text":"","category":"section"},{"location":"public_private_APIs/#Internal-implicit-Euler-method","page":"Public and Private APIs","title":"Internal implicit Euler method","text":"","category":"section"},{"location":"public_private_APIs/","page":"Public and Private APIs","title":"Public and Private APIs","text":"pdepe","category":"page"},{"location":"public_private_APIs/#SkeelBerzins.pdepe","page":"Public and Private APIs","title":"SkeelBerzins.pdepe","text":"pdepe(m, pdefunction, icfunction, bdfunction, xmesh, tspan ; solver=:euler, tstep=1e-3, hist=false, sparsity=:sparseArray)\n\nSolve 1D elliptic and/or parabolic partial differential equation(s) using the spatial discretization method described in [1]. The time discretization is either done by the implicit Euler method (internal method) or by using a ODE/DAE solver from the DifferentialEquations.jl package. For more information on how to define the different inputs to solve a problem, look at (link problem definition...).\n\nInput arguments:\n\nm: scalar refering to the symmetry of the problem. It can either take the value m=0, m=1 or m=2 representing       cartesian, cylindrical or spherical coordinates respectively.\npdefunction: Function. Defines the PDE(s) formulation that incorporates capacity, flux and source terms.\nicfunction: Function. Defines the initial condition of the system to solve (if tstep   initial condition from the ODE/DAE problem,                else if tstep ==  initial value used for the newton solver).\nbdfunction: Function. Defines the boundary conditions of the problem.\nxmesh: 1 dimensional array representing the mesh on which the user wants to obtain the solution.\ntspan: tuple (t0, t{end}) representing the time interval of the problem.\n\nKeyword arguments:\n\nsolver: choice of the time discretization either use :euler for internal implicit Euler method or :diffEq for the DifferentialEquations.jl package (by default :euler).\ntstep: define a time step when using the implicit Euler method (by default to 1e-3). When set to tstep=Inf, it solves the stationary version of the problem.\nhist: flag to return with the solution a list of 1d array with the history from the newton solver (by default false).\nsparsity: choice of the type of matrix use to store the jacobian (by default :sparseArray).\n\nReturns a RecursiveArrayTools.DiffEqArray, a SkeelBerzins.ProblemDefinition structure or a 1D Array, depending on the chosen solver.\n\n\n\n\n\npdepe(m, pdefunction, icfunction, bdfunction, xmesh ; hist=false, sparsity=:sparseArray)\n\nSolve 1D elliptic PDE(s) using the spatial discretization method described in 1. Performs one step of the implicit Euler method. For more information, look at link implicit Euler...\n\nInput arguments:\n\nm: scalar refering to the symmetry of the problem. It can either take the value m=0, m=1 or m=2 representing       cartesian, cylindrical or spherical coordinates respectively.\npdefunction: Function. Defines the PDE(s) formulation which includes the capacity, flux and source terms (capacity term should be set to 0).\nicfunction: Function. It defines the initial value used for the Newton solver.\nbdfunction: Function. Defines the boundary conditions of the problem.\nxmesh: 1 dimensional array reprensenting the mesh on which the user wants to get the solution.\n\nKeyword arguments:\n\nhist: flag to return with the solution a list of 1d array with the history from the newton solver (by default false).\nsparsity: choice of the type of matrix use to store the jacobian (by default :sparseArray).\n\nReturns a 1D Array with the solution at the points from the spatial discretization xmesh.\n\n\n\n\n\n","category":"function"},{"location":"public_private_APIs/#Compatibility-with-DifferentialEquations.jl","page":"Public and Private APIs","title":"Compatibility with DifferentialEquations.jl","text":"","category":"section"},{"location":"public_private_APIs/","page":"Public and Private APIs","title":"Public and Private APIs","text":"SciMLBase.ODEProblem\nBase.reshape","category":"page"},{"location":"public_private_APIs/#Base.reshape","page":"Public and Private APIs","title":"Base.reshape","text":"reshape(sol_ODE, problem)\n\nReshape the solution sol_ODE obtained by the DifferentialEquations.jl package to obtain the solution at time t as a 2D-Array of size (npde,Nx). \n\nIndeed since in the spatial discretization, we flattened the problem, the solution has a similar size.  So by reshaping the solution, we get a solution organised by unknows.\n\n\n\n\n\n","category":"function"},{"location":"public_private_APIs/#Private-API","page":"Public and Private APIs","title":"Private API","text":"","category":"section"},{"location":"public_private_APIs/","page":"Public and Private APIs","title":"Public and Private APIs","text":"These methods should only be considered for developers or people trying to understand the inner workings of the package.","category":"page"},{"location":"public_private_APIs/#Spatial-Discretization","page":"Public and Private APIs","title":"Spatial Discretization","text":"","category":"section"},{"location":"public_private_APIs/","page":"Public and Private APIs","title":"Public and Private APIs","text":"assemble!","category":"page"},{"location":"public_private_APIs/#Newton-solvers","page":"Public and Private APIs","title":"Newton solvers","text":"","category":"section"},{"location":"public_private_APIs/","page":"Public and Private APIs","title":"Public and Private APIs","text":"newton\nnewton_stat","category":"page"},{"location":"public_private_APIs/#Problem-definition","page":"Public and Private APIs","title":"Problem definition","text":"","category":"section"},{"location":"public_private_APIs/#Compatibility-with-DifferentialEquations.jl-2","page":"Public and Private APIs","title":"Compatibility with DifferentialEquations.jl","text":"","category":"section"},{"location":"public_private_APIs/","page":"Public and Private APIs","title":"Public and Private APIs","text":"The ODEFunction constructor is implicitely defined in the ODEProblem and so doesn't need to be considered by the user to solve the problem with the DifferentialEquations.jl package.","category":"page"},{"location":"public_private_APIs/","page":"Public and Private APIs","title":"Public and Private APIs","text":"SciMLBase.ODEFunction","category":"page"},{"location":"solvers/#Solvers","page":"Solvers","title":"Solvers","text":"","category":"section"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"Now that we formulated the problem in the expected format, we can introduce the solvers enabling to solve one-dimensional parabolic and elliptic nonlinear partial differential equations.","category":"page"},{"location":"solvers/#Internal-method:-implicit-Euler-method","page":"Solvers","title":"Internal method: implicit Euler method","text":"","category":"section"},{"location":"solvers/#Parabolic-equations","page":"Solvers","title":"Parabolic equations","text":"","category":"section"},{"location":"solvers/#Elliptic-Equations","page":"Solvers","title":"Elliptic Equations","text":"","category":"section"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"Only the internal method will work to solve time independant problems. The implicit Euler method is writen in the following way:","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"It results that we get the solution from the stationary problem by running one iteration from the implicit Euler method.","category":"page"},{"location":"solvers/#Solve-with-DifferentialEquations.jl","page":"Solvers","title":"Solve with DifferentialEquations.jl","text":"","category":"section"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"SkeelBerzins.jl is also compatible with the DifferentialEquations.jl package. It is possible to return the data from the problem in a ProblemDefinition structure, then to define an ODEFunction, an ODEProblem and solve it using any ODE/DAE solvers from DifferentialEquations.jl .","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Markdown\nMarkdown.parse(\"\"\"\n$(read(\"../../README.md\",String))\n\"\"\")","category":"page"}]
}
